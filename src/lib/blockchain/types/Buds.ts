/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import type BN from "bn.js";
import type { ContractOptions } from "web3-eth-contract";
import type { EventLog } from "web3-core";
import type { EventEmitter } from "events";
import type {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

export interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type AllowedSeaDropUpdated = ContractEventLog<{
  allowedSeaDrop: string[];
  0: string[];
}>;
export type Approval = ContractEventLog<{
  owner: string;
  approved: string;
  tokenId: string;
  0: string;
  1: string;
  2: string;
}>;
export type ApprovalForAll = ContractEventLog<{
  owner: string;
  operator: string;
  approved: boolean;
  0: string;
  1: string;
  2: boolean;
}>;
export type BatchMetadataUpdate = ContractEventLog<{
  _fromTokenId: string;
  _toTokenId: string;
  0: string;
  1: string;
}>;
export type ConsecutiveTransfer = ContractEventLog<{
  fromTokenId: string;
  toTokenId: string;
  from: string;
  to: string;
  0: string;
  1: string;
  2: string;
  3: string;
}>;
export type ContractURIUpdated = ContractEventLog<{
  newContractURI: string;
  0: string;
}>;
export type MaxSupplyUpdated = ContractEventLog<{
  newMaxSupply: string;
  0: string;
}>;
export type OwnershipTransferred = ContractEventLog<{
  previousOwner: string;
  newOwner: string;
  0: string;
  1: string;
}>;
export type Paused = ContractEventLog<{
  account: string;
  0: string;
}>;
export type PotentialOwnerUpdated = ContractEventLog<{
  newPotentialAdministrator: string;
  0: string;
}>;
export type ProvenanceHashUpdated = ContractEventLog<{
  previousHash: string;
  newHash: string;
  0: string;
  1: string;
}>;
export type RoyaltyInfoUpdated = ContractEventLog<{
  receiver: string;
  bps: string;
  0: string;
  1: string;
}>;
export type SeaDropTokenDeployed = ContractEventLog<{}>;
export type Transfer = ContractEventLog<{
  from: string;
  to: string;
  tokenId: string;
  0: string;
  1: string;
  2: string;
}>;
export type Unpaused = ContractEventLog<{
  account: string;
  0: string;
}>;

export interface Buds extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): Buds;
  clone(): Buds;
  methods: {
    OPERATOR_FILTER_REGISTRY(): NonPayableTransactionObject<string>;

    acceptOwnership(): NonPayableTransactionObject<void>;

    addGameRole(_game: string): NonPayableTransactionObject<void>;

    approve(
      operator: string,
      tokenId: number | string | BN
    ): NonPayableTransactionObject<void>;

    balanceOf(owner: string): NonPayableTransactionObject<string>;

    baseURI(): NonPayableTransactionObject<string>;

    cancelOwnershipTransfer(): NonPayableTransactionObject<void>;

    contractURI(): NonPayableTransactionObject<string>;

    emitBatchMetadataUpdate(
      fromTokenId: number | string | BN,
      toTokenId: number | string | BN
    ): NonPayableTransactionObject<void>;

    explicitOwnershipOf(
      tokenId: number | string | BN
    ): NonPayableTransactionObject<{
      addr: string;
      startTimestamp: string;
      burned: boolean;
      extraData: string;
    }>;

    explicitOwnershipsOf(
      tokenIds: (number | string | BN)[]
    ): NonPayableTransactionObject<
      {
        addr: string;
        startTimestamp: string;
        burned: boolean;
        extraData: string;
      }[]
    >;

    gameAddGameRole(_game: string): NonPayableTransactionObject<void>;

    gameRemoveGameRole(_game: string): NonPayableTransactionObject<void>;

    gameRoles(arg0: string): NonPayableTransactionObject<boolean>;

    getApproved(
      tokenId: number | string | BN
    ): NonPayableTransactionObject<string>;

    getMintStats(minter: string): NonPayableTransactionObject<{
      minterNumMinted: string;
      currentTotalSupply: string;
      maxSupply: string;
      0: string;
      1: string;
      2: string;
    }>;

    isApprovedForAll(
      owner: string,
      operator: string
    ): NonPayableTransactionObject<boolean>;

    maxSupply(): NonPayableTransactionObject<string>;

    mintSeaDrop(
      minter: string,
      quantity: number | string | BN
    ): NonPayableTransactionObject<void>;

    multiConfigure(config: {
      maxSupply: number | string | BN;
      baseURI: string;
      contractURI: string;
      seaDropImpl: string;
      publicDrop: {
        mintPrice: number | string | BN;
        startTime: number | string | BN;
        endTime: number | string | BN;
        maxTotalMintableByWallet: number | string | BN;
        feeBps: number | string | BN;
        restrictFeeRecipients: boolean;
      };
      dropURI: string;
      allowListData: {
        merkleRoot: string | number[];
        publicKeyURIs: string[];
        allowListURI: string;
      };
      creatorPayoutAddress: string;
      provenanceHash: string | number[];
      allowedFeeRecipients: string[];
      disallowedFeeRecipients: string[];
      allowedPayers: string[];
      disallowedPayers: string[];
      tokenGatedAllowedNftTokens: string[];
      tokenGatedDropStages: {
        mintPrice: number | string | BN;
        maxTotalMintableByWallet: number | string | BN;
        startTime: number | string | BN;
        endTime: number | string | BN;
        dropStageIndex: number | string | BN;
        maxTokenSupplyForStage: number | string | BN;
        feeBps: number | string | BN;
        restrictFeeRecipients: boolean;
      }[];
      disallowedTokenGatedAllowedNftTokens: string[];
      signers: string[];
      signedMintValidationParams: {
        minMintPrice: number | string | BN;
        maxMaxTotalMintableByWallet: number | string | BN;
        minStartTime: number | string | BN;
        maxEndTime: number | string | BN;
        maxMaxTokenSupplyForStage: number | string | BN;
        minFeeBps: number | string | BN;
        maxFeeBps: number | string | BN;
      }[];
      disallowedSigners: string[];
    }): NonPayableTransactionObject<void>;

    name(): NonPayableTransactionObject<string>;

    owner(): NonPayableTransactionObject<string>;

    ownerOf(tokenId: number | string | BN): NonPayableTransactionObject<string>;

    pause(): NonPayableTransactionObject<void>;

    paused(): NonPayableTransactionObject<boolean>;

    provenanceHash(): NonPayableTransactionObject<string>;

    removeGameRole(_game: string): NonPayableTransactionObject<void>;

    renounceOwnership(): NonPayableTransactionObject<void>;

    royaltyAddress(): NonPayableTransactionObject<string>;

    royaltyBasisPoints(): NonPayableTransactionObject<string>;

    royaltyInfo(
      arg0: number | string | BN,
      _salePrice: number | string | BN
    ): NonPayableTransactionObject<{
      receiver: string;
      royaltyAmount: string;
      0: string;
      1: string;
    }>;

    "safeTransferFrom(address,address,uint256)"(
      from: string,
      to: string,
      tokenId: number | string | BN
    ): NonPayableTransactionObject<void>;

    "safeTransferFrom(address,address,uint256,bytes)"(
      from: string,
      to: string,
      tokenId: number | string | BN,
      data: string | number[]
    ): NonPayableTransactionObject<void>;

    setApprovalForAll(
      operator: string,
      approved: boolean
    ): NonPayableTransactionObject<void>;

    setBaseURI(newBaseURI: string): NonPayableTransactionObject<void>;

    setContractURI(newContractURI: string): NonPayableTransactionObject<void>;

    setMaxSupply(
      newMaxSupply: number | string | BN
    ): NonPayableTransactionObject<void>;

    setProvenanceHash(
      newProvenanceHash: string | number[]
    ): NonPayableTransactionObject<void>;

    setRoyaltyInfo(newInfo: {
      royaltyAddress: string;
      royaltyBps: number | string | BN;
    }): NonPayableTransactionObject<void>;

    supportsInterface(
      interfaceId: string | number[]
    ): NonPayableTransactionObject<boolean>;

    symbol(): NonPayableTransactionObject<string>;

    tokenURI(
      tokenId: number | string | BN
    ): NonPayableTransactionObject<string>;

    tokensOfOwner(owner: string): NonPayableTransactionObject<string[]>;

    tokensOfOwnerIn(
      owner: string,
      start: number | string | BN,
      stop: number | string | BN
    ): NonPayableTransactionObject<string[]>;

    totalSupply(): NonPayableTransactionObject<string>;

    transferFrom(
      from: string,
      to: string,
      tokenId: number | string | BN
    ): NonPayableTransactionObject<void>;

    transferOwnership(
      newPotentialOwner: string
    ): NonPayableTransactionObject<void>;

    unpause(): NonPayableTransactionObject<void>;

    updateAllowList(
      seaDropImpl: string,
      allowListData: {
        merkleRoot: string | number[];
        publicKeyURIs: string[];
        allowListURI: string;
      }
    ): NonPayableTransactionObject<void>;

    updateAllowedFeeRecipient(
      seaDropImpl: string,
      feeRecipient: string,
      allowed: boolean
    ): NonPayableTransactionObject<void>;

    updateAllowedSeaDrop(
      allowedSeaDrop: string[]
    ): NonPayableTransactionObject<void>;

    updateCreatorPayoutAddress(
      seaDropImpl: string,
      payoutAddress: string
    ): NonPayableTransactionObject<void>;

    updateDropURI(
      seaDropImpl: string,
      dropURI: string
    ): NonPayableTransactionObject<void>;

    updatePayer(
      seaDropImpl: string,
      payer: string,
      allowed: boolean
    ): NonPayableTransactionObject<void>;

    updatePublicDrop(
      seaDropImpl: string,
      publicDrop: {
        mintPrice: number | string | BN;
        startTime: number | string | BN;
        endTime: number | string | BN;
        maxTotalMintableByWallet: number | string | BN;
        feeBps: number | string | BN;
        restrictFeeRecipients: boolean;
      }
    ): NonPayableTransactionObject<void>;

    updateSignedMintValidationParams(
      seaDropImpl: string,
      signer: string,
      signedMintValidationParams: {
        minMintPrice: number | string | BN;
        maxMaxTotalMintableByWallet: number | string | BN;
        minStartTime: number | string | BN;
        maxEndTime: number | string | BN;
        maxMaxTokenSupplyForStage: number | string | BN;
        minFeeBps: number | string | BN;
        maxFeeBps: number | string | BN;
      }
    ): NonPayableTransactionObject<void>;

    updateTokenGatedDrop(
      seaDropImpl: string,
      allowedNftToken: string,
      dropStage: {
        mintPrice: number | string | BN;
        maxTotalMintableByWallet: number | string | BN;
        startTime: number | string | BN;
        endTime: number | string | BN;
        dropStageIndex: number | string | BN;
        maxTokenSupplyForStage: number | string | BN;
        feeBps: number | string | BN;
        restrictFeeRecipients: boolean;
      }
    ): NonPayableTransactionObject<void>;
  };
  events: {
    AllowedSeaDropUpdated(cb?: Callback<AllowedSeaDropUpdated>): EventEmitter;
    AllowedSeaDropUpdated(
      options?: EventOptions,
      cb?: Callback<AllowedSeaDropUpdated>
    ): EventEmitter;

    Approval(cb?: Callback<Approval>): EventEmitter;
    Approval(options?: EventOptions, cb?: Callback<Approval>): EventEmitter;

    ApprovalForAll(cb?: Callback<ApprovalForAll>): EventEmitter;
    ApprovalForAll(
      options?: EventOptions,
      cb?: Callback<ApprovalForAll>
    ): EventEmitter;

    BatchMetadataUpdate(cb?: Callback<BatchMetadataUpdate>): EventEmitter;
    BatchMetadataUpdate(
      options?: EventOptions,
      cb?: Callback<BatchMetadataUpdate>
    ): EventEmitter;

    ConsecutiveTransfer(cb?: Callback<ConsecutiveTransfer>): EventEmitter;
    ConsecutiveTransfer(
      options?: EventOptions,
      cb?: Callback<ConsecutiveTransfer>
    ): EventEmitter;

    ContractURIUpdated(cb?: Callback<ContractURIUpdated>): EventEmitter;
    ContractURIUpdated(
      options?: EventOptions,
      cb?: Callback<ContractURIUpdated>
    ): EventEmitter;

    MaxSupplyUpdated(cb?: Callback<MaxSupplyUpdated>): EventEmitter;
    MaxSupplyUpdated(
      options?: EventOptions,
      cb?: Callback<MaxSupplyUpdated>
    ): EventEmitter;

    OwnershipTransferred(cb?: Callback<OwnershipTransferred>): EventEmitter;
    OwnershipTransferred(
      options?: EventOptions,
      cb?: Callback<OwnershipTransferred>
    ): EventEmitter;

    Paused(cb?: Callback<Paused>): EventEmitter;
    Paused(options?: EventOptions, cb?: Callback<Paused>): EventEmitter;

    PotentialOwnerUpdated(cb?: Callback<PotentialOwnerUpdated>): EventEmitter;
    PotentialOwnerUpdated(
      options?: EventOptions,
      cb?: Callback<PotentialOwnerUpdated>
    ): EventEmitter;

    ProvenanceHashUpdated(cb?: Callback<ProvenanceHashUpdated>): EventEmitter;
    ProvenanceHashUpdated(
      options?: EventOptions,
      cb?: Callback<ProvenanceHashUpdated>
    ): EventEmitter;

    RoyaltyInfoUpdated(cb?: Callback<RoyaltyInfoUpdated>): EventEmitter;
    RoyaltyInfoUpdated(
      options?: EventOptions,
      cb?: Callback<RoyaltyInfoUpdated>
    ): EventEmitter;

    SeaDropTokenDeployed(cb?: Callback<SeaDropTokenDeployed>): EventEmitter;
    SeaDropTokenDeployed(
      options?: EventOptions,
      cb?: Callback<SeaDropTokenDeployed>
    ): EventEmitter;

    Transfer(cb?: Callback<Transfer>): EventEmitter;
    Transfer(options?: EventOptions, cb?: Callback<Transfer>): EventEmitter;

    Unpaused(cb?: Callback<Unpaused>): EventEmitter;
    Unpaused(options?: EventOptions, cb?: Callback<Unpaused>): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(
    event: "AllowedSeaDropUpdated",
    cb: Callback<AllowedSeaDropUpdated>
  ): void;
  once(
    event: "AllowedSeaDropUpdated",
    options: EventOptions,
    cb: Callback<AllowedSeaDropUpdated>
  ): void;

  once(event: "Approval", cb: Callback<Approval>): void;
  once(event: "Approval", options: EventOptions, cb: Callback<Approval>): void;

  once(event: "ApprovalForAll", cb: Callback<ApprovalForAll>): void;
  once(
    event: "ApprovalForAll",
    options: EventOptions,
    cb: Callback<ApprovalForAll>
  ): void;

  once(event: "BatchMetadataUpdate", cb: Callback<BatchMetadataUpdate>): void;
  once(
    event: "BatchMetadataUpdate",
    options: EventOptions,
    cb: Callback<BatchMetadataUpdate>
  ): void;

  once(event: "ConsecutiveTransfer", cb: Callback<ConsecutiveTransfer>): void;
  once(
    event: "ConsecutiveTransfer",
    options: EventOptions,
    cb: Callback<ConsecutiveTransfer>
  ): void;

  once(event: "ContractURIUpdated", cb: Callback<ContractURIUpdated>): void;
  once(
    event: "ContractURIUpdated",
    options: EventOptions,
    cb: Callback<ContractURIUpdated>
  ): void;

  once(event: "MaxSupplyUpdated", cb: Callback<MaxSupplyUpdated>): void;
  once(
    event: "MaxSupplyUpdated",
    options: EventOptions,
    cb: Callback<MaxSupplyUpdated>
  ): void;

  once(event: "OwnershipTransferred", cb: Callback<OwnershipTransferred>): void;
  once(
    event: "OwnershipTransferred",
    options: EventOptions,
    cb: Callback<OwnershipTransferred>
  ): void;

  once(event: "Paused", cb: Callback<Paused>): void;
  once(event: "Paused", options: EventOptions, cb: Callback<Paused>): void;

  once(
    event: "PotentialOwnerUpdated",
    cb: Callback<PotentialOwnerUpdated>
  ): void;
  once(
    event: "PotentialOwnerUpdated",
    options: EventOptions,
    cb: Callback<PotentialOwnerUpdated>
  ): void;

  once(
    event: "ProvenanceHashUpdated",
    cb: Callback<ProvenanceHashUpdated>
  ): void;
  once(
    event: "ProvenanceHashUpdated",
    options: EventOptions,
    cb: Callback<ProvenanceHashUpdated>
  ): void;

  once(event: "RoyaltyInfoUpdated", cb: Callback<RoyaltyInfoUpdated>): void;
  once(
    event: "RoyaltyInfoUpdated",
    options: EventOptions,
    cb: Callback<RoyaltyInfoUpdated>
  ): void;

  once(event: "SeaDropTokenDeployed", cb: Callback<SeaDropTokenDeployed>): void;
  once(
    event: "SeaDropTokenDeployed",
    options: EventOptions,
    cb: Callback<SeaDropTokenDeployed>
  ): void;

  once(event: "Transfer", cb: Callback<Transfer>): void;
  once(event: "Transfer", options: EventOptions, cb: Callback<Transfer>): void;

  once(event: "Unpaused", cb: Callback<Unpaused>): void;
  once(event: "Unpaused", options: EventOptions, cb: Callback<Unpaused>): void;
}
